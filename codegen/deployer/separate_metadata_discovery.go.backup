package main

import (
	"errors"
	"go/types"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

var caller = `package main

import (
	"fmt"

	alias "{{ .Pkg }}"
)

func main() {
	spec := alias.{{ .Func }}Metadata
	fmt.Printf("{{ .Func }}: %#v\n", spec)
}
`

type Trigger struct {
	Pkg  string
	Func string
}

func main2() {
	triggers, err := extractTriggers("acme.com/example")
	if err != nil {
		log.Fatal(err)
	}

	tmpl, err := template.New("generator").Parse(caller)
	if err != nil {
		log.Fatalln(err)
	}

	for _, trig := range triggers {
		tmpl.Execute(os.Stdout, trig)
	}
}

func extractTriggers(pkg string) ([]Trigger, error) {
	exports, err := loadExports(pkg)
	if err != nil {
		return nil, err
	}

	var triggers []Trigger
	for _, exp := range exports {
		triggers = append(triggers, Trigger{
			Pkg:  pkg,
			Func: strings.TrimSuffix(exp.Name(), "Metadata"),
		})
	}

	return triggers, nil
}

func loadExports(pkg string) ([]types.Object, error) {
	cfg := &packages.Config{Mode: packages.LoadTypes}
	pkgs, err := packages.Load(cfg, pkg)
	if err != nil {
		return nil, err
	}
	if packages.PrintErrors(pkgs) > 0 {
		return nil, err
	}

	var results []types.Object
	scope := pkgs[0].Types.Scope()
	for _, symbol := range scope.Names() {
		typeInfo := scope.Lookup(symbol)
		if isTrigger(symbol, typeInfo) {
			results = append(results, typeInfo)
		}
	}

	if results == nil {
		return nil, errors.New("no exported member")
	}

	return results, nil
}

func isTrigger(name string, typeInfo types.Object) bool {
	if !strings.HasSuffix(name, "Metadata") {
		return false
	}

	if !typeInfo.Exported() {
		return false
	}

	typeName := typeInfo.Type().String()
	return typeName == "firebase.com/functions.HTTPTrigger"
}
